jmeter接口串联
http协议
http协议代表内容类型的字段
tcp3次握手
tcp4次挥手
长链接字段
5个io模型是怎么实现的


进程线程区别
进程间的通信方式


linux查看内存命令
查看端口命令
查找文件
命名管道在linux中具体怎么实现的

**最熟悉的数据结构是什么**
 - 数据结构分为8类有：数组、栈、队列、链表、树、散列表、堆、图。数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。
 - 数组：数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。
 - 栈：栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。
 - 队列：队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队。 
 - 链表：链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。 
 - 树：树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
 - 散列表：散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。
 - 堆：堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。
 - 图：图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。

**python gil**
 - 在Python中GIL是Global Interpreter Lock，即全局解释锁的缩写，保证了同一时刻只有一个线程在一个CPU上执行字节码，无法将多个线程映射到多个CPU上。这是CPython解释器的缺陷，由于CPython是大部分环境下默认的Python执行环境，而很多库都是基于CPython编写的，因此很多人将GIL归结为Python的问题。这也是使得标准版本的Python并不能实现真正的多线程并发的直接原因。简单来说就是，一个Python进程永远不能在同一时刻使用多个CPU核心。GIL被设计来保护线程安全，由于多线程共享变量，如果不能很好的进行线程同步，多线程非常容易将线程改乱。

**python tuple和字典的区别**
 - 元祖不可变，有序列。字典无序列，可变

**python常用容器*
 - 列表、字典、元组、字符串、集合
 - 字符串	字符/不可变/序列	序列：有顺序，能索引、切片，获取元素更灵活
 - 列表	变量/可变/序列	可变：适用于需要修改元素个数和内容的情况，如录入学生信息 序列：有顺序，能索引、切片，获取元素更灵活
 - 元组	变量/不可变/序列	不可变：当元素个数固定且不需要改变，优先用元组，能够节省内存
 - 字典	键值对/可变/散列	键值对：哈希原理，查找速度很快，但相对列表占用更大的内存，键名唯一，代码可读性更好 散列：元素没有顺序，无法直接索引，无法切片
 - 集合	不重复变量/可变/散列	相对于只有键没有值得字典，主要用于数学运算

**python list去重**
 - 用set
   ```
   ids = [1,4,3,3,4,2,3,4,5,6,1]
   ids = list(set(ids))
   ```
 - 用list.append()

 **排序算法有哪些**
  - 冒泡排序（稳定）
    - 从第一个数开始，相邻元素两两对比，小的数放前面。（每循环一次，最后一个数都会被确定下来，为每轮的最大数）
  - 插入排序（稳定）
  - 希尔排序（不稳定）
  - 归并排序（稳定）
  - 快速排序（不稳定）
  - 怎么理解各种排序算法的时间复杂度和空间复杂度？
    - 时间复杂度: 一个算法执行所耗费的时间。
    - 空间复杂度: 运行完一个程序所需内存的大小。

 **快排**
  - 快速排序思想：先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。 左右分别用一个空数组去存储比较后的数据。最后递归执行上述操作，直到数组长度<=1。
  - 特点：快速，常用。缺点是需要另外声明两个数组，浪费了内存空间资源。


