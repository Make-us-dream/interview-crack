jmeter接口串联
http协议
http协议代表内容类型的字段

**tcp3次握手**
 - 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
 - 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
 - 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
 - 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
 - 如果已经建立了连接，但是客户端突然出现故障了怎么办？
   - TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

**tcp4次挥手**
 - 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
 - 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
 - 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
 - 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
 - 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
 - 6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
 - 为什么连接的时候是三次握手，关闭的时候却是四次握手？
   - 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**长链接字段**
 - connection：keep-alive
 - HTTP keep-alive 也称为 HTTP 长连接。它通过重用一个 TCP 连接来发送/接收多个 HTTP请求，来减少创建/关闭多个 TCP 连接的开销。
 - keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。
 - 优点：keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）
 - 缺点：如果客户端在接收完所有的信息之后还没有关闭连接，则服务端相应的资源还在被占用（尽管已经没用了）

**5个io模型是怎么实现的**
 - 阻塞IO,非阻塞IO,IO多路复用,信号驱动IO，异步IO是五种常见的IO模型。

**进程线程区别**
 - 进程是程序，线程在进程下行进。异步通过多个多线程实现，或者多进程。
 
**进程间的通信方式**


**linux查看内存命令**
 - `cat /proc/meminfo`
**查看端口命令**
 - `netstat  -lanp`(查看服务器上有哪些服务和端口)
查找文件
 - `find -name "*.txt"`
命名管道在linux中具体怎么实现的

**最熟悉的数据结构是什么**
 - 数据结构分为8类有：数组、栈、队列、链表、树、散列表、堆、图。数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。
 - 数组：数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。
 - 栈：栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。
 - 队列：队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队。 
 - 链表：链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。 
 - 树：树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
 - 散列表：散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。
 - 堆：堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。
 - 图：图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。

**python gil**
 - 在Python中GIL是Global Interpreter Lock，即全局解释锁的缩写，保证了同一时刻只有一个线程在一个CPU上执行字节码，无法将多个线程映射到多个CPU上。这是CPython解释器的缺陷，由于CPython是大部分环境下默认的Python执行环境，而很多库都是基于CPython编写的，因此很多人将GIL归结为Python的问题。这也是使得标准版本的Python并不能实现真正的多线程并发的直接原因。简单来说就是，一个Python进程永远不能在同一时刻使用多个CPU核心。GIL被设计来保护线程安全，由于多线程共享变量，如果不能很好的进行线程同步，多线程非常容易将线程改乱。

**python tuple和字典的区别**
 - 元祖不可变，有序列。字典无序列，可变

**python常用容器**
 - 列表、字典、元组、字符串、集合
 - 字符串	字符/不可变/序列	序列：有顺序，能索引、切片，获取元素更灵活
 - 列表	变量/可变/序列	可变：适用于需要修改元素个数和内容的情况，如录入学生信息 序列：有顺序，能索引、切片，获取元素更灵活
 - 元组	变量/不可变/序列	不可变：当元素个数固定且不需要改变，优先用元组，能够节省内存
 - 字典	键值对/可变/散列	键值对：哈希原理，查找速度很快，但相对列表占用更大的内存，键名唯一，代码可读性更好 散列：元素没有顺序，无法直接索引，无法切片
 - 集合	不重复变量/可变/散列	相对于只有键没有值得字典，主要用于数学运算

**python list去重**
 - 用set
   ```
   ids = [1,4,3,3,4,2,3,4,5,6,1]
   ids = list(set(ids))
   ```
 - 用list.append()

 **排序算法有哪些**
  - 冒泡排序（稳定）
    - 从第一个数开始，相邻元素两两对比，小的数放前面。（每循环一次，最后一个数都会被确定下来，为每轮的最大数）
  - 插入排序（稳定）
  - 希尔排序（不稳定）
  - 归并排序（稳定）
  - 快速排序（不稳定）
  - 怎么理解各种排序算法的时间复杂度和空间复杂度？
    - 时间复杂度: 一个算法执行所耗费的时间。
    - 空间复杂度: 运行完一个程序所需内存的大小。

 **快排**
  - 快速排序思想：先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。 左右分别用一个空数组去存储比较后的数据。最后递归执行上述操作，直到数组长度<=1。
  - 特点：快速，常用。缺点是需要另外声明两个数组，浪费了内存空间资源。

 **sql注入**
  - 出于安全考虑，需要过滤从页面传递过来的字符
  - 通过SQL语句，实现无账号登录，甚至篡改数据库
  - 防止sql注入
    - 检查变量数据类型和格式
    - 过滤特殊符号
    - 绑定变量，使用预编译语句


